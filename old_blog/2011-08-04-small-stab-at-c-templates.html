<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Small Stab at C++ Templates | Farid Zakaria’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Small Stab at C++ Templates" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Templates Never really had a chance to play around with C++ Templates, since most work during my undergrad didn&#39;t require it and I had found that most companies avoided writing any templates themselves (at most only using the STL ones). I noticed at my current job that they had implemented a few times their own LinkList classes since they are not including/using the STL. Looking over some of the implementations (some a bit more generic than others using void pointers) wanted me to try and write my own LinkList template class. Although most would quickly deem it worthless of an attempt and clearly trivial, writing the class helped solidify a few deeper understandings for me in C++. The use of the keyword typename. Since C++ templates are generated at compile time, they are done in a multipass fashion. During the first pass, certain types are not yet defined however can be referenced, i.e. LinkList::Iterator. In order to tell the compiler that Iterator is a type and not a variable, the keyword typename is used.&lt;/li&gt; Proper const and reference correctness. There were some additional nuances that I was unaware of when working with const types. For instance, when returning a reference via an inspection method (const method), the return type must be const as well. You can actually some pretty crazy shit with templates, namely metaprogramming. The STL is pretty crazy and I take it for granted in most software projects I do. I was scratching my head for a bit on just how I wanted to implement my Iterator... &lt;/ul&gt; The STL is pretty crazy and I take it for granted in most software projects I do. Here&#39;s my stab... #ifndef _LINKLIST_H_ #define _LINKLIST_H_" />
<meta property="og:description" content="Templates Never really had a chance to play around with C++ Templates, since most work during my undergrad didn&#39;t require it and I had found that most companies avoided writing any templates themselves (at most only using the STL ones). I noticed at my current job that they had implemented a few times their own LinkList classes since they are not including/using the STL. Looking over some of the implementations (some a bit more generic than others using void pointers) wanted me to try and write my own LinkList template class. Although most would quickly deem it worthless of an attempt and clearly trivial, writing the class helped solidify a few deeper understandings for me in C++. The use of the keyword typename. Since C++ templates are generated at compile time, they are done in a multipass fashion. During the first pass, certain types are not yet defined however can be referenced, i.e. LinkList::Iterator. In order to tell the compiler that Iterator is a type and not a variable, the keyword typename is used.&lt;/li&gt; Proper const and reference correctness. There were some additional nuances that I was unaware of when working with const types. For instance, when returning a reference via an inspection method (const method), the return type must be const as well. You can actually some pretty crazy shit with templates, namely metaprogramming. The STL is pretty crazy and I take it for granted in most software projects I do. I was scratching my head for a bit on just how I wanted to implement my Iterator... &lt;/ul&gt; The STL is pretty crazy and I take it for granted in most software projects I do. Here&#39;s my stab... #ifndef _LINKLIST_H_ #define _LINKLIST_H_" />
<link rel="canonical" href="https://fzakaria.com/old_blog/2011-08-04-small-stab-at-c-templates.html" />
<meta property="og:url" content="https://fzakaria.com/old_blog/2011-08-04-small-stab-at-c-templates.html" />
<meta property="og:site_name" content="Farid Zakaria’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-08-04T14:04:41-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Small Stab at C++ Templates" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2011-08-04T14:04:41-07:00","datePublished":"2011-08-04T14:04:41-07:00","description":"Templates Never really had a chance to play around with C++ Templates, since most work during my undergrad didn&#39;t require it and I had found that most companies avoided writing any templates themselves (at most only using the STL ones). I noticed at my current job that they had implemented a few times their own LinkList classes since they are not including/using the STL. Looking over some of the implementations (some a bit more generic than others using void pointers) wanted me to try and write my own LinkList template class. Although most would quickly deem it worthless of an attempt and clearly trivial, writing the class helped solidify a few deeper understandings for me in C++. The use of the keyword typename. Since C++ templates are generated at compile time, they are done in a multipass fashion. During the first pass, certain types are not yet defined however can be referenced, i.e. LinkList::Iterator. In order to tell the compiler that Iterator is a type and not a variable, the keyword typename is used.&lt;/li&gt; Proper const and reference correctness. There were some additional nuances that I was unaware of when working with const types. For instance, when returning a reference via an inspection method (const method), the return type must be const as well. You can actually some pretty crazy shit with templates, namely metaprogramming. The STL is pretty crazy and I take it for granted in most software projects I do. I was scratching my head for a bit on just how I wanted to implement my Iterator... &lt;/ul&gt; The STL is pretty crazy and I take it for granted in most software projects I do. Here&#39;s my stab... #ifndef _LINKLIST_H_ #define _LINKLIST_H_","headline":"Small Stab at C++ Templates","mainEntityOfPage":{"@type":"WebPage","@id":"https://fzakaria.com/old_blog/2011-08-04-small-stab-at-c-templates.html"},"url":"https://fzakaria.com/old_blog/2011-08-04-small-stab-at-c-templates.html"}</script>
<!-- End Jekyll SEO tag -->

        <link type="application/atom+xml" rel="alternate" href="https://fzakaria.com/feed.xml" title="Farid Zakaria&apos;s Blog" />
        <link rel="stylesheet" type="text/css" href="/assets/css/base.css">
        <link rel="icon" type="image/x-icon" href="/assets/images/avatar.ico">
        <link rel="alternate" type="application/atom+xml" title="Farid Zakaria's Blog" href="/feed.xml">

        <link ref="">

        
        
        <link href="/assets/css/highlightjs-default-theme.css" rel="stylesheet" />
        

        
            <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-35360900-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-35360900-1');
</script>

        

    </head>
    <body>
        
        <script src="/assets/js/highlight.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        

        <div class="container">
            <h1 class="page-title">
    <a class="rss pull-right" href="/feed.xml"><i class="fa fa-rss"></i></a>
    Small Stab at C++ Templates
</h1>

<div class="content">
    
    <p class="date">
        Published 2011-08-04
        on <a href="/">Farid Zakaria's Blog</a>
        <span class="hidden-xs">
          &mdash;
          <a href="/old_blog/2011-08-04-small-stab-at-c-templates.html">
            Permalink
          </a>
        </span>
    </p>
    
    <article>
      <h2>Templates</h2>
<p>
Never really had a chance to play around with <a href="http://www.cplusplus.com/doc/tutorial/templates/">C++ Templates</a>, since most work during my undergrad didn't require it and I had found that most companies avoided writing any templates themselves (at most only using the STL ones).</p>
<p>
I noticed at my current job that they had implemented a few times their own LinkList classes since they are not including/using the STL. Looking over some of the implementations (some a bit more generic than others using void pointers) wanted me to try and write my own LinkList template class.</p>
<p>
Although most would quickly deem it worthless of an attempt and clearly trivial, writing the class helped solidify a few deeper understandings for me in C++.</p>
<ul>
<li>The use of the keyword <em>typename</em>. Since C++ templates are generated at compile time, they are done in a multipass fashion. During the first pass, certain types are not yet defined however can be referenced, i.e. LinkList<T>::Iterator. In order to tell the compiler that Iterator is a type and not a variable, the keyword typename is used.</li>
<li>Proper <em>const</em> and <em>reference</em> correctness. There were some additional nuances that I was unaware of when working with const types. For instance, when returning a reference via an inspection method (const method), the return type must be const as well.</li>
<li>You can actually some pretty <em>crazy shit</em> with templates, namely <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">metaprogramming</a>.</li>
<li>The STL is pretty crazy and I take it for granted in most software projects I do. I was scratching my head for a bit on just how I wanted to implement my Iterator...</li>
</ul>
<blockquote><p>The STL is pretty crazy and I take it for granted in most software projects I do.</p></blockquote>
<p><!--more--><br />
<em>Here's my stab...</em></p>
<pre>
<code>
#ifndef _LINKLIST_H_
#define _LINKLIST_H_

template<class T>
class LinkList
{
private:
    typedef T value_type;
	typedef T&amp; reference_type;
	typedef const T &amp; const_reference_type;
	typedef T * pointer_type;
	typedef const T * const_pointer_type;

	class Node
	{
     public:
        Node(value_type data): m_data(data), 
                               m_next(NULL), 
                               m_previous(NULL){}
        ~Node(){}
        
        void setNext(Node * next) { 
            this->m_next = next; 
        }
        Node * getNext() const { 
            return this->m_next; 
        }
        
        void setPrevious(Node * prev) { 
            this->m_previous = prev; 
        }
        Node * getPrevious() const { 
            return this->m_previous; 
        }
        
        void setData(const_reference_type data) { 
            m_data = data; 
        }
        reference_type getData() { 
            return m_data; 
        }
        
    private:
        Node * m_next;
        Node * m_previous;
        value_type m_data;
	};
    
    unsigned int m_size;
    Node * m_head;
    Node * m_tail;
	
public:
    class Iterator
    {
    public:
        Iterator &amp; operator++() { //prefix
            this->m_current = m_current->getNext(); 
            return *this; 
        } 
        Iterator operator++(int) //postfix
        {
            Iterator result = *this;
            ++(*this);
            return result;
        }
        reference_type operator*() { 
            return m_current->getData(); 
        } 
        pointer_type operator->() const { 
            return &amp;this->m_current->getData(); 
        }
        bool operator== (const Iterator &amp; rhs) const { 
            return this->m_current == rhs.m_current; 
        }
        bool operator!=(const Iterator &amp; rhs) const { 
            return !(*this == rhs); 
        }
        
    private:
        friend class LinkList<T>;
        Iterator(Node * node) : m_current(node){}
        Node * m_current;
        
    };

    LinkList(): m_size(0), 
                   m_head(NULL), 
                   m_tail(NULL) {}
    virtual ~LinkList();
    
    void push_back(const_reference_type item);
    void push_front(const_reference_type item);
    void pop_front();
    void pop_back();
    
    Iterator begin() const { 
        return Iterator(m_head); 
    }
    Iterator end() const { 
        return Iterator(NULL); 
    }
    
    Iterator find(const_reference_type value)const;
    void clear();
    unsigned int size() const { return m_size; }
    bool empty() const { return m_size == 0; }
    
    
};

template<class T>
LinkList<T>::~LinkList()
{
    this->clear();
}

template<class T>
void LinkList<T>::clear()
{    
    for (unsigned int i = 0 ; i < m_size; ++i)
    {
        this->pop_back();
    }
}

template<class T>
typename LinkList<T>::Iterator LinkList<T>::find(const_reference_type value) const
{
    Node * curr = m_head;
    while (curr != NULL)
    {
        if (curr->getData() == value)
        {
            return Iterator(curr);
        }
        
        curr = curr->getNext();
    }
    
    return Iterator( this->end() );
}

template<class T>
void LinkList<T>::push_back(const_reference_type item)
{
    Node * newNode = new Node(item);
    m_size+=1;
    if (this->m_head == NULL)
    {
        this->m_head = newNode;
        this->m_tail = m_head;
        return;
    }
    newNode->setPrevious(this->m_tail);
    this->m_tail->setNext( newNode );
    this->m_tail = newNode;
    return;
}

template<class T>
void LinkList<T>::push_front(const_reference_type item)
{
    Node * newNode = new Node(item);
    m_size+=1;
    if (this->m_head == NULL)
    {
        this->m_head = newNode;
        this->m_tail = m_head;
        return;
    }
    this->m_head->setPrevious(newNode);
    newNode->setNext(this->m_head);
    this->m_head = newNode;
    return;
}

template<class T>
void LinkList<T>::pop_back()
{
    if (this->m_tail != NULL)
    {
        m_size-=1;
        Node * popNode = this->m_tail;
        this->m_tail = popNode->getPrevious();
        delete popNode;
        if(this->m_tail == NULL)
        {
            this->m_head = NULL;
        }
    }
    
}

template<class T>
void LinkList<T>::pop_front()
{
    if (this->m_head != NULL)
    {
        m_size-=1;
        Node * popNode = this->m_head;
        this->m_head = popNode->getNext();
        delete popNode;
        if(this->m_head == NULL)
        {
            this->m_tail = NULL;
        }
    } 
}
#endif
</code>
</pre>


<hr />
    </article>
</div>

<div class="sidebar">
    <hr class="visible-xs" />
    <img class="avatar" src="/assets/images/avatar-164.png" alt="A photo of my dog Moose" title="My dog Moose"/>
    <p>I'm a software engineer, father and wishful amateur surfer. If you've come seeking my political views; you've found the wrong <a href="https://fareedzakaria.com/">Fareed</a>.</p>
    <div class="external-links">
      <p>
        <span class="context">linkedin</span>
        <a href="https://www.linkedin.com/in/fmzakari/">fmzakari</a>
      </p>
      <p>
        <span class="context">github</span>
        <a href="https://github.com/fzakaria">fzakaria</a>
      </p>
      <p>
        <span class="context">email</span>
        <a href="mailto:farid.m.zakaria@gmail.com">farid.m.zakaria@gmail.com</a>
      </p>
      <p>
        <span class="context">pgp</span>
        <a href="/publickey.txt">D1B232E7</a>
      </p>
      <p>
        <a href="/archive">Archive</a>
      </p>
      <p>
        <a href="/old_blog/">Historic WordPress Blog</a>
      </p>
      <!--
      <p>
        Web friendly version of my <a href="/resume/index.html">resume</a>.
      </p>
    </div>
    <h3>Projects</h3>
    <p>
      <a href="/projects/">Click here</a> for some personal
      projects I've worked on.
    </p>
    <h3>Old Blog</h3>
    <p>
      <a href="/old_blog/">Click here</a> for the archive
      of my old blog posts from Wordpress.
    </p>
    -->
    
    <h3>Recent Posts</h3>
    
    <div class="post-stub">
      2025-02-02<br />
      <a href="/2025/02/02/nix-string-interpolation-of-directories-gone-awry.html">Nix: string interpolation of directories gone awry</a>
    </div>
    
    <div class="post-stub">
      2025-01-28<br />
      <a href="/2025/01/28/bazel-build-event-protocol-viewer.html">Bazel: Build Event Protocol Viewer</a>
    </div>
    
    <div class="post-stub">
      2025-01-12<br />
      <a href="/2025/01/12/bazel-knowledge-be-mindful-of-build-without-the-bytes.html">Bazel Knowledge: Be mindful of Build Without the Bytes (bwob)</a>
    </div>
    
    
    <h3>License</h3>
    <p style="font-size: 10pt">
    The content for this site is
    <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>.
    The <a href="https://github.com/SirCmpwn/ddjekyll">inspiration for the theme</a> for this site is
    © Drew Devault.
    </p>
    <div class="spacer" style="margin-top: 30px;"></div>
    
    <p><a href="https://github.com/fzakaria/fzakaria.com/edit/master/_old_blog/2011-08-04-small-stab-at-c-templates.html">
      Improve this page @ 417ff2d
    </a></p>

</div>
        </div>
    </body>
</html>
