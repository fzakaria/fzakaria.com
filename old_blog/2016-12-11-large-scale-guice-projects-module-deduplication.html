<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Large Scale Guice Projects - Module Deduplication | Farid Zakaria’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Large Scale Guice Projects - Module Deduplication" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="If you come from a large Java shop, you&#39;ve likely heard of or encountered Guice -- Google&#39;s lightweight dependency injection framework; analogous to Spring. First time users of Guice will usually be starry eyed amazed at the ability to get type safe dependency and the seemingly modular way in which to bundle up your dependencies into Modules. Much of the tutorials, guides and best practices found online though are targeted towards smaller codebases, and anyone in large Java shops will have likely hit the spaghetti of configuration and AbstractModule dependencies to get your code to boot up -- seemingly ruining the modularity of using a dependency injection framework. This post is aimed at some best practice I&#39;ve found for keeping AbstractModule composable and easy to understand. If you don&#39;t want to read to the end just checkout my project on solving Guice deduplication -- guice-dedupe Composition The biggest hurdle large projects will face in Guice is that you&#39;ll want to keep Modules resuable and more importantly self-contained. Consider the following example where I have a JSON class that is bound in a module, and two other modules want to make use of it. public class Example { public static class JsonSerializer { //Implementation not important } public static class JsonModule extends AbstractModule { @Override protected void configure() { bind(JsonSerializer.class); } } public static class ModuleA extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } public static class ModuleB extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } } We&#39;d like to make use of the install option, so that a consumer can either use ModuleB or ModuleA and the necessary bindings are self-contained. The problem arises if ModuleA and ModuleB are used -- you&#39;ll be treated with a Multiple Binding Exception. Many codebases, simply remove the installation of Module dependencies and move the mess of figuring out the right set of final modules you need at moment you try to create the injector. What a mess! The way to solve this is to use Guice&#39;s built-in de-duplication code. For the most part it works out of the box, unless you are using @Provides in your modules. Simply change all your existing AbstractModule to SingletonModule from the library guice-dedupe and you&#39;ll get modules that are fully self-contained now even with providers." />
<meta property="og:description" content="If you come from a large Java shop, you&#39;ve likely heard of or encountered Guice -- Google&#39;s lightweight dependency injection framework; analogous to Spring. First time users of Guice will usually be starry eyed amazed at the ability to get type safe dependency and the seemingly modular way in which to bundle up your dependencies into Modules. Much of the tutorials, guides and best practices found online though are targeted towards smaller codebases, and anyone in large Java shops will have likely hit the spaghetti of configuration and AbstractModule dependencies to get your code to boot up -- seemingly ruining the modularity of using a dependency injection framework. This post is aimed at some best practice I&#39;ve found for keeping AbstractModule composable and easy to understand. If you don&#39;t want to read to the end just checkout my project on solving Guice deduplication -- guice-dedupe Composition The biggest hurdle large projects will face in Guice is that you&#39;ll want to keep Modules resuable and more importantly self-contained. Consider the following example where I have a JSON class that is bound in a module, and two other modules want to make use of it. public class Example { public static class JsonSerializer { //Implementation not important } public static class JsonModule extends AbstractModule { @Override protected void configure() { bind(JsonSerializer.class); } } public static class ModuleA extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } public static class ModuleB extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } } We&#39;d like to make use of the install option, so that a consumer can either use ModuleB or ModuleA and the necessary bindings are self-contained. The problem arises if ModuleA and ModuleB are used -- you&#39;ll be treated with a Multiple Binding Exception. Many codebases, simply remove the installation of Module dependencies and move the mess of figuring out the right set of final modules you need at moment you try to create the injector. What a mess! The way to solve this is to use Guice&#39;s built-in de-duplication code. For the most part it works out of the box, unless you are using @Provides in your modules. Simply change all your existing AbstractModule to SingletonModule from the library guice-dedupe and you&#39;ll get modules that are fully self-contained now even with providers." />
<link rel="canonical" href="https://fzakaria.com/old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html" />
<meta property="og:url" content="https://fzakaria.com/old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html" />
<meta property="og:site_name" content="Farid Zakaria’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-12-11T12:13:04-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Large Scale Guice Projects - Module Deduplication" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-12-11T12:13:04-08:00","datePublished":"2016-12-11T12:13:04-08:00","description":"If you come from a large Java shop, you&#39;ve likely heard of or encountered Guice -- Google&#39;s lightweight dependency injection framework; analogous to Spring. First time users of Guice will usually be starry eyed amazed at the ability to get type safe dependency and the seemingly modular way in which to bundle up your dependencies into Modules. Much of the tutorials, guides and best practices found online though are targeted towards smaller codebases, and anyone in large Java shops will have likely hit the spaghetti of configuration and AbstractModule dependencies to get your code to boot up -- seemingly ruining the modularity of using a dependency injection framework. This post is aimed at some best practice I&#39;ve found for keeping AbstractModule composable and easy to understand. If you don&#39;t want to read to the end just checkout my project on solving Guice deduplication -- guice-dedupe Composition The biggest hurdle large projects will face in Guice is that you&#39;ll want to keep Modules resuable and more importantly self-contained. Consider the following example where I have a JSON class that is bound in a module, and two other modules want to make use of it. public class Example { public static class JsonSerializer { //Implementation not important } public static class JsonModule extends AbstractModule { @Override protected void configure() { bind(JsonSerializer.class); } } public static class ModuleA extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } public static class ModuleB extends AbstractModule { @Override protected void configure() { install(new JsonModule()); } } } We&#39;d like to make use of the install option, so that a consumer can either use ModuleB or ModuleA and the necessary bindings are self-contained. The problem arises if ModuleA and ModuleB are used -- you&#39;ll be treated with a Multiple Binding Exception. Many codebases, simply remove the installation of Module dependencies and move the mess of figuring out the right set of final modules you need at moment you try to create the injector. What a mess! The way to solve this is to use Guice&#39;s built-in de-duplication code. For the most part it works out of the box, unless you are using @Provides in your modules. Simply change all your existing AbstractModule to SingletonModule from the library guice-dedupe and you&#39;ll get modules that are fully self-contained now even with providers.","headline":"Large Scale Guice Projects - Module Deduplication","mainEntityOfPage":{"@type":"WebPage","@id":"https://fzakaria.com/old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html"},"url":"https://fzakaria.com/old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html"}</script>
<!-- End Jekyll SEO tag -->

        <link type="application/atom+xml" rel="alternate" href="https://fzakaria.com/feed.xml" title="Farid Zakaria&apos;s Blog" />
        <link rel="stylesheet" type="text/css" href="/assets/css/base.css">
        <link rel="icon" type="image/x-icon" href="/assets/images/avatar.ico">
        <link rel="alternate" type="application/atom+xml" title="Farid Zakaria's Blog" href="/feed.xml">

        <link ref="">

        
        
        <link href="/assets/css/highlightjs-default-theme.css" rel="stylesheet" />
        

        
            <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-35360900-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-35360900-1');
</script>

        

    </head>
    <body>
        
        <script src="/assets/js/highlight.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        

        <div class="container">
            <h1 class="page-title">
    <a class="rss pull-right" href="/feed.xml"><i class="fa fa-rss"></i></a>
    Large Scale Guice Projects - Module Deduplication
</h1>

<div class="content">
    
    <p class="date">
        Published 2016-12-11
        on <a href="/">Farid Zakaria's Blog</a>
        <span class="hidden-xs">
          &mdash;
          <a href="/old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html">
            Permalink
          </a>
        </span>
    </p>
    
    <article>
      <p>
If you come from a large Java shop, you've likely heard of or encountered <a href="https://github.com/google/guice">Guice</a> -- Google's lightweight dependency injection framework; analogous to Spring.</p>
<p>
First time users of Guice will usually be <em>starry eyed</em> amazed at the ability to get type safe dependency and the seemingly modular way in which to bundle up your dependencies into <strong>Modules</strong>.</p>
<p>
Much of the tutorials, guides and best practices found online though are targeted towards smaller codebases, and anyone in large Java shops will have likely hit the spaghetti of configuration and AbstractModule dependencies to get your code to boot up -- seemingly ruining the modularity of using a dependency injection framework.<br />
This post is aimed at some best practice I've found for keeping <strong>AbstractModule</strong> composable and easy to understand.</p>
<blockquote><p>If you don't want to read to the end just checkout my project on solving Guice deduplication -- <a href="https://github.com/fzakaria/guide-dedupe">guice-dedupe</a></p></blockquote>
<h3>Composition</h3>
<p>
The biggest hurdle large projects will face in Guice is that you'll want to keep Modules resuable and more importantly self-contained.</p>
<p>
Consider the following example where I have a JSON class that is bound in a module, and two other modules want to make use of it.</p>
<pre class="lang:java decode:true " title="Guide binding duplication example " >public class Example {

  public static class JsonSerializer {
    //Implementation not important
  }

  public static class JsonModule extends AbstractModule {

    @Override
    protected void configure() {
      bind(JsonSerializer.class);
    }

  }


  public static class ModuleA extends AbstractModule {

    @Override
    protected void configure() {
      install(new JsonModule());
    }

  }

  public static class ModuleB extends AbstractModule {

    @Override
    protected void configure() {
      install(new JsonModule());
    }

  }


}</pre>
<p>
We'd like to make use of the <em>install</em> option, so that a consumer can either use ModuleB <strong>or</strong> ModuleA and the necessary bindings are self-contained. The problem arises if ModuleA <strong>and</strong> ModuleB are used -- you'll be treated with a <em>Multiple Binding Exception</em>.</p>
<p>
Many codebases, simply remove the installation of Module dependencies and move the mess of figuring out the right set of final modules you need at moment you try to create the injector. <em>What a mess!</em></p>
<p>
The way to solve this is to use Guice's built-in de-duplication code. For the most part it works out of the box, unless you are using <em>@Provides</em> in your modules.<br />
Simply change all your existing AbstractModule to <strong>SingletonModule</strong> from the library <a href="https://github.com/fzakaria/guide-dedupe">guice-dedupe</a> and you'll get modules that are fully self-contained now even with providers.</p>


<hr />
    </article>
</div>

<div class="sidebar">
    <hr class="visible-xs" />
    <img class="avatar" src="/assets/images/avatar-164.png" alt="A photo of my dog Moose" title="My dog Moose"/>
    <p>I'm a software engineer, father and wishful amateur surfer. If you've come seeking my political views; you've found the wrong <a href="https://fareedzakaria.com/">Fareed</a>.</p>
    <div class="external-links">
      <p>
        <span class="context">linkedin</span>
        <a href="https://www.linkedin.com/in/fmzakari/">fmzakari</a>
      </p>
      <p>
        <span class="context">github</span>
        <a href="https://github.com/fzakaria">fzakaria</a>
      </p>
      <p>
        <span class="context">email</span>
        <a href="mailto:farid.m.zakaria@gmail.com">farid.m.zakaria@gmail.com</a>
      </p>
      <p>
        <span class="context">pgp</span>
        <a href="/publickey.txt">D1B232E7</a>
      </p>
      <p>
        <a href="/archive">Archive</a>
      </p>
      <p>
        <a href="/old_blog/">Historic WordPress Blog</a>
      </p>
      <!--
      <p>
        Web friendly version of my <a href="/resume/index.html">resume</a>.
      </p>
    </div>
    <h3>Projects</h3>
    <p>
      <a href="/projects/">Click here</a> for some personal
      projects I've worked on.
    </p>
    <h3>Old Blog</h3>
    <p>
      <a href="/old_blog/">Click here</a> for the archive
      of my old blog posts from Wordpress.
    </p>
    -->
    
    <h3>Recent Posts</h3>
    
    <div class="post-stub">
      2025-02-02<br />
      <a href="/2025/02/02/nix-string-interpolation-of-directories-gone-awry.html">Nix: string interpolation of directories gone awry</a>
    </div>
    
    <div class="post-stub">
      2025-01-28<br />
      <a href="/2025/01/28/bazel-build-event-protocol-viewer.html">Bazel: Build Event Protocol Viewer</a>
    </div>
    
    <div class="post-stub">
      2025-01-12<br />
      <a href="/2025/01/12/bazel-knowledge-be-mindful-of-build-without-the-bytes.html">Bazel Knowledge: Be mindful of Build Without the Bytes (bwob)</a>
    </div>
    
    
    <h3>License</h3>
    <p style="font-size: 10pt">
    The content for this site is
    <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>.
    The <a href="https://github.com/SirCmpwn/ddjekyll">inspiration for the theme</a> for this site is
    © Drew Devault.
    </p>
    <div class="spacer" style="margin-top: 30px;"></div>
    
    <p><a href="https://github.com/fzakaria/fzakaria.com/edit/master/_old_blog/2016-12-11-large-scale-guice-projects-module-deduplication.html">
      Improve this page @ 417ff2d
    </a></p>

</div>
        </div>
    </body>
</html>
