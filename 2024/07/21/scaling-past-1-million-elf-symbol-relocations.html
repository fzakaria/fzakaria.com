<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Scaling past 1 million ELF symbol relocations | Farid Zakaria’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Scaling past 1 million ELF symbol relocations" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Note This is a follow up to my previous post on speeding up elf relocations for store based systems. I wrote earlier about some impressive speedups that can be achieved by foregoing the typical dynamic linking that can be applied to systems such as Nix where the dependencies for a given application are static." />
<meta property="og:description" content="Note This is a follow up to my previous post on speeding up elf relocations for store based systems. I wrote earlier about some impressive speedups that can be achieved by foregoing the typical dynamic linking that can be applied to systems such as Nix where the dependencies for a given application are static." />
<link rel="canonical" href="https://fzakaria.com/2024/07/21/scaling-past-1-million-elf-symbol-relocations.html" />
<meta property="og:url" content="https://fzakaria.com/2024/07/21/scaling-past-1-million-elf-symbol-relocations.html" />
<meta property="og:site_name" content="Farid Zakaria’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-07-21T11:25:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Scaling past 1 million ELF symbol relocations" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-21T11:25:00-07:00","datePublished":"2024-07-21T11:25:00-07:00","description":"Note This is a follow up to my previous post on speeding up elf relocations for store based systems. I wrote earlier about some impressive speedups that can be achieved by foregoing the typical dynamic linking that can be applied to systems such as Nix where the dependencies for a given application are static.","headline":"Scaling past 1 million ELF symbol relocations","mainEntityOfPage":{"@type":"WebPage","@id":"https://fzakaria.com/2024/07/21/scaling-past-1-million-elf-symbol-relocations.html"},"url":"https://fzakaria.com/2024/07/21/scaling-past-1-million-elf-symbol-relocations.html"}</script>
<!-- End Jekyll SEO tag -->

        <link type="application/atom+xml" rel="alternate" href="https://fzakaria.com/feed.xml" title="Farid Zakaria&apos;s Blog" />
        <link rel="stylesheet" type="text/css" href="/assets/css/base.css">
        <link rel="icon" type="image/x-icon" href="/assets/images/avatar.ico">
        <link rel="alternate" type="application/atom+xml" title="Farid Zakaria's Blog" href="/feed.xml">

        <link ref="">

        
        

        
            <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-35360900-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-35360900-1');
</script>

        

    </head>
    <body>
        

        <div class="container">
            <h1 class="page-title">
    <a class="rss pull-right" href="/feed.xml"><i class="fa fa-rss"></i></a>
    Scaling past 1 million ELF symbol relocations
</h1>

<div class="content">
    
    <p class="date">
        Published 2024-07-21
        on <a href="/">Farid Zakaria's Blog</a>
        <span class="hidden-xs">
          &mdash;
          <a href="/2024/07/21/scaling-past-1-million-elf-symbol-relocations.html">
            Permalink
          </a>
        </span>
    </p>
    
    <article>
      <blockquote>
  <p><strong>Note</strong><br />
This is a follow up to my previous post on <a href="/2024/05/03/speeding-up-elf-relocations-for-store-based-systems.html">speeding up elf relocations for store based systems</a>.</p>
</blockquote>

<p>I wrote earlier about some impressive speedups that can be achieved by foregoing the typical dynamic linking that can be applied to systems such as Nix where the dependencies for a given application are static.</p>

<!--more-->

<p>The first attempt at memoization ELF symbol relocations involved <code class="language-plaintext highlighter-rouge">strcmp</code> on the shared library name.</p>

<p>The code would memoize the relocations into entries such as the one below.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
  </span><span class="nl">"addend"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"st_value"</span><span class="p">:</span><span class="w"> </span><span class="mi">16392</span><span class="p">,</span><span class="w">
  </span><span class="nl">"st_size"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">
  </span><span class="nl">"offset"</span><span class="p">:</span><span class="w"> </span><span class="mi">16368</span><span class="p">,</span><span class="w">
  </span><span class="nl">"symbol_name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"global_variable"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"symbol_dso_name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/nix/store/fni9dgkmimqi54q308zi37ycpfx5mq54-libfoo/lib/libfoo.so"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"dso_name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/nix/store/6xqcsfhh1pk6s9cib8lkp5k9ybf05sq7-patched_hello_world/bin/hello_world"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>For each entry, the appropriate <code class="language-plaintext highlighter-rouge">struct dso</code> pointer would be located by <code class="language-plaintext highlighter-rouge">strcmp</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">find_dso</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">dso</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">dso</span><span class="p">;</span> <span class="n">dso</span><span class="o">=</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dso</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">dso</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>🙄 Of course this is non-optimal and is <code class="language-plaintext highlighter-rouge">θ(nm)</code>; but I wanted to prove that <em>it would work first</em>.</p>

<p>Now that I’ve proven efficacy, I began optimizing the lookups.</p>

<p>A <em>small-trick</em> I was able to leverage was that the linked list produced by the dynamic linker must be deterministic in order; otherwise symbol interposition (shadowing) could be varied across invocations.</p>

<p>I was able to store the <em>index into the linked list</em> rather than the name itself to find the <code class="language-plaintext highlighter-rouge">struct dso</code>.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"symbol_dso_index"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"dso_index"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="nf">find_dso</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">index</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This brought the lookup to <code class="language-plaintext highlighter-rouge">θ(n)</code> – <em>can we do better?</em></p>

<p>Turns out we can get to <code class="language-plaintext highlighter-rouge">θ(k)</code> (constant time), if we are willing to pay <em>one-time cost</em> of converting the linked list to an array for index-based access.</p>

<p>We iterate the array once to discover the size of the array and then leverage VLA, variable length arrays, to allocate a dynamic array onto the stack.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">make_dso_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dso</span> <span class="o">**</span><span class="n">dso_table</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">app</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dso_table</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">app</span><span class="p">;</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">number_of_dso</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">app</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reloc_symbols_from_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span><span class="n">app</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">CachedRelocInfo</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span>
                                     <span class="kt">size_t</span> <span class="n">reloc_count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">number_of_dsos</span> <span class="o">=</span> <span class="n">number_of_dso</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">dso</span> <span class="o">*</span> <span class="n">dso_table</span><span class="p">[</span><span class="n">number_of_dsos</span><span class="p">];</span>
    <span class="n">make_dso_table</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">dso_table</span><span class="p">);</span>
</code></pre></div></div>

<p>Do these optimization make a difference in practice, especially given how much time is spent on dynamic linking? 🤔</p>

<p>Turns out for sufficiently large number of symbol relocations distributed over multiple shared libraries, we can see even more drastic results.</p>

<p>On a synthetic benchmark, creating 1000 shared objects each with 1000 symbols  for a total of 1_000_000 (million) total relocations can see speedups as large as <strong>18-22x</strong>.</p>

<p><img src="/assets/images/benchmark_heatmap.png" alt="benchmark heatmap" /></p>

<p>A noticeable speedup was seen in the established benchmark <a href="https://github.com/LLNL/pynamic">pynamic</a>. Pynamic is a benchmark written by Lawrence Livermore National Laboratory (LLNL) to simulate internal software written.</p>

<p>Similar to the prior synthetic benchmark, Pynamic creates an MPI application which starts an embedded Python interpreter and links it against a desired amount of Python modules.</p>

<p>Running the same configuration as outlined in <a href="https://asc.llnl.gov/sites/asc/files/2020-09/pynamic-coral-2-benchmark-summary-v1-2.pdf">documentation</a> written by LLNL shows speedups as large as <strong>8x</strong> (3.672 secs ± 0.084 vs. 26.152 secs ± 0.095). 🏎️</p>

<p>Finding real world applications beyond the software Pynamic itself may be emulating which contain 1_000_000+ symbol relocations proved challenging; but seeing the time needed to perform the relocations (26 seconds) it is understandable.</p>

<p>Ulrich Drepper (long time glibc author) in fact devotes a large section of his guide on <a href="https://www.cs.dartmouth.edu/~sergey/cs258/ABI/UlrichDrepper-How-To-Write-Shared-Libraries.pdf">How to Write Shared Libraries</a>. Portions of the advice centers around shortening symbol names and being judicious about which symbols are exported to minimize the number of symbol relocations created. This optimization technique eschews much of that advice and allows applications to scale beyond traditional limits and still appear relatively responsive in startup.</p>

<p>Similar to the <a href="https://en.wikipedia.org/wiki/C10k_problem">C10K</a> problem faced in the earlier 2000s as the Linux kernel was attempting to scale to 10_000 connections; this work allows applications to think about scaling to 1 million symbol relocations.</p>

<p><em>Go forth and link.</em></p>


<hr />
    </article>
</div>

<div class="sidebar">
    <hr class="visible-xs" />
    <img class="avatar" src="/assets/images/avatar-164.png" alt="A photo of my dog Moose" title="My dog Moose"/>
    <p>I'm a software engineer, father and wishful amateur surfer. If you've come seeking my political views; you've found the wrong <a href="https://fareedzakaria.com/">Fareed</a>.</p>
    <div class="external-links">
      <p>
        <span class="context">linkedin</span>
        <a href="https://www.linkedin.com/in/fmzakari/">fmzakari</a>
      </p>
      <p>
        <span class="context">github</span>
        <a href="https://github.com/fzakaria">fzakaria</a>
      </p>
      <p>
        <span class="context">email</span>
        <a href="mailto:farid.m.zakaria@gmail.com">farid.m.zakaria@gmail.com</a>
      </p>
      <p>
        <span class="context">pgp</span>
        <a href="/publickey.txt">D1B232E7</a>
      </p>
      <p>
        <a href="/archive">Archive</a>
      </p>
      <p>
        <a href="/old_blog/">Historic WordPress Blog</a>
      </p>
      <!--
      <p>
        Web friendly version of my <a href="/resume/index.html">resume</a>.
      </p>
    </div>
    <h3>Projects</h3>
    <p>
      <a href="/projects/">Click here</a> for some personal
      projects I've worked on.
    </p>
    <h3>Old Blog</h3>
    <p>
      <a href="/old_blog/">Click here</a> for the archive
      of my old blog posts from Wordpress.
    </p>
    -->
    
    <h3>Recent Posts</h3>
    
    <div class="post-stub">
      2025-02-02<br />
      <a href="/2025/02/02/nix-string-interpolation-of-directories-gone-awry.html">Nix: string interpolation of directories gone awry</a>
    </div>
    
    <div class="post-stub">
      2025-01-28<br />
      <a href="/2025/01/28/bazel-build-event-protocol-viewer.html">Bazel: Build Event Protocol Viewer</a>
    </div>
    
    <div class="post-stub">
      2025-01-12<br />
      <a href="/2025/01/12/bazel-knowledge-be-mindful-of-build-without-the-bytes.html">Bazel Knowledge: Be mindful of Build Without the Bytes (bwob)</a>
    </div>
    
    
    <h3>License</h3>
    <p style="font-size: 10pt">
    The content for this site is
    <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>.
    The <a href="https://github.com/SirCmpwn/ddjekyll">inspiration for the theme</a> for this site is
    © Drew Devault.
    </p>
    <div class="spacer" style="margin-top: 30px;"></div>
    
    <p><a href="https://github.com/fzakaria/fzakaria.com/edit/master/_posts/2024-07-21-scaling-past-1-million-elf-symbol-relocations.md">
      Improve this page @ 417ff2d
    </a></p>

</div>
        </div>
    </body>
</html>
